#!/usr/bin/python
from p2p.peer import InfinitiPeer
from infiniti.params import *
from p2p.protocol.serializers import *
from p2p.protocol.queues import MemPoolManager
from p2p.rpc import RPCServer
import infiniti.logger as logger
import threading, socket
import sys, traceback
import sched, time, os

from utils.db import open_db 

from json import load
from urllib2 import urlopen

try:
    ip_address = load(urlopen('https://api.ipify.org/?format=json'))['ip'] 
    port = param_query(NETWORK,'p2p_port')
except Exception:
    print "Internet connection not found!"
    sys.exit(0)

class Infiniti(InfinitiPeer):
    db = None   
    socket = None
    mempool_manager = None
    s_send_ping = None
    s_get_peers = None
    s_ping_event = None
    s_peers_event = None
    counter = 0

    def message_received(self, message_header, message):
        self.logger.recv_message("{0} - {1} - {2}".format(self.peerip, message_header.command, str(message)))
        super(Infiniti, self).message_received(message_header, message)

    def send_message(self, message):
        self.logger.send_message("{0} - {1}".format(self.peerip, str(message)))
        super(Infiniti, self).send_message(message)

    def send_ping(self): 
        p = Ping()
        self.send_message(p)
        self.s_ping_event = self.s_send_ping.enter(617, 1, self.send_ping, ())

    def get_peers(self):
        ga = GetAddr()
        self.send_message(ga)
        self.s_peers_event = self.s_get_peers.enter(631, 1, self.get_peers, ())

    def connected(self):
        # Get list of peers
        self.is_connected = True
        self.db.update_peer(self,0)
        self.logger.status_message("{0} - Connected.".format(self.peerip))
        #self.s_get_peers = sched.scheduler(time.time, time.sleep)
        #self.s_peers_event = self.s_get_peers.enter(630, 1, self.get_peers, ())
        #self.s_get_peers.run()

        gp = GetAddr()
        self.send_message(gp)
        mp = MemPool()
        self.send_message(mp)
        # Ask for the top block we have processed in the database.
        # If there are none, use the genesis block
        if self.mempool_manager.can_getblocks():
            # block for other threads
            self.mempool_manager.getblocks_not_ok()     
            last_block = self.db.get_last_block()
            if not last_block:
                _hash = param_query(NETWORK,'genesis_hash')
            else:
                _hash = last_block[0]
            gh = GetBlocks([_hash])
            self.send_message(gh)
            # we're good for new blocks
            self.mempool_manager.getblocks_ok()     

    def handle_inv(self, message_header, message):
        self.logger.status_message("Received new inventory data from {0}".format(self.peerip))  
        gd = GetData()
        gd.inventory = message.inventory
        self.send_message(gd)

    def handle_tx(self, message_header, message):
        self.logger.status_message("Received new mempool transaction from {0}".format(self.peerip))
        self.logger.status_message("{0}".format(message))
        self.manager.add(message.calculate_hash())

    def handle_block(self, message_header, message):
        self.logger.status_message("Received new block {0} from {1}".format(message.calculate_hash(), self.peerip))
        message.save(self.db)

    def handle_pong(self,messaage_header, message):
        gp = SmsgPing()
        self.send_message(gp)

    def handle_addr(self, message_header, message):
        """
        This method will handle incoming inventories of network 
        peers.
        Args:
            message_header: The message header
            message: The list of peers
        """
        self.logger.status_message("Unpacking new peers from {0}".format(self.peerip))
        for peer in message.addresses:
            peer.save(self.db)

class PeerThread (threading.Thread):
    def __init__(self, threadID, name, counter, client, mempool_manager):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
        self.client = client
        self.client.counter = counter
        self.client.mempool_manager = mempool_manager
    def stop(self):
        self.client.exit = True
    def run(self):
        self.client.open(ip_address,port)
        self.client.loop()  
        return

class SpiderThread(threading.Thread):
    counter = 0
    def __init__(self, threadID, name, counter, mempool_manager):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
        self.threads = []
        self.halt = False
        self.mempool_manager = mempool_manager
        self.last_peers = 0
        self.counter = 0

    def stop(self):
        logger.status_message("Network Spider Stopping.")
        self.halt = True
        for t in self.threads:
            t.stop()

    def load_peer_db(self):
        # trigger garbage collection closing db
        db = open_db(os.path.join(DATA_PATH,"peers"))
        q = db.RangeIter()
        return q

    def get_peers(self):
        if self.last_peers < time.time() - 60: # try new peers every 60 seconds
            # Clean up dead threads         
            for t in self.threads:
                if t.client.exit or t.client.error:
                    self.threads.remove(t)
            peers = self.load_peer_db() 
            for k,v in peers:
                peer_ip, peer_port = k.split(":")
                peer_found = False
                # make sure it's not already running
                for t in self.threads:
                    if peer_ip == t.client.peerip:
                        peer_found = True
                if not peer_found:
                    client = Infiniti(logger, peer_ip, peer_port)
                    self.counter += 1
                    thread = PeerThread(self.counter, "Thread-" + client.peerip, self.counter, client, self.mempool_manager)
                    thread.daemon=True
                    thread.start()
                    self.threads.append(thread)
            self.last_peers = time.time()                                                        

    def run(self):
        self.counter = 0
        logger.status_message("Network Spider Started.")
        while not self.halt:
            self.get_peers()

"""
class MemPoolThread(threading.Thread):
    def __init__(self, threadID, name, counter, manager):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
        self.manager = manager
        self.halt = False

    def run(self):
        while not self.halt:
            pass
        logger.status_message("MemPool Stopping.")

    def stop(self):
        self.halt = True        
class RPCServerThread(threading.Thread):
    def __init__(self, threadID, name, counter, ip='localhost', port=8000):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
        self.rpc_ip = ip
        self.rpc_port = port
        self.rpc_server = RPCServer()
        self.halt = False

    def run(self):
        self.rpc_server.start(self.rpc_ip,self.rpc_port)

    def stop(self):
        self.halt = True
        self.rpc_server.httpd.shutdown()
        logger.status_message("RPC server shutdown.")
"""

def main():
    try:
        logger.status_message("Infiniti Started.")
        # Get list of peers
        # Iterate list of peers and create client objects
        # Main program loop.
        counter = 0
        mempool_manager = None
        """
        mempool_manager = MemPoolManager()
        #mempool_thread = MemPoolThread(counter, "MemPool", counter, mempool_manager)
        #mempool_thread.start()
        counter += 1
        rpc_server = RPCServerThread(counter, "RPCServer", counter)
        rpc_server.start()
        counter += 1
        """
        spider = SpiderThread(counter, "Spider", counter, mempool_manager)
        spider.start()
        counter += 1
        while True: 
            time.sleep(1)
    except KeyboardInterrupt:
        logger.status_message("Infiniti Shutting down.")
        #rpc_server.stop()
        #mempool_manager.empty()
        #mempool_thread.manager.empty()
        #mempool_thread.stop()
        spider.stop()
        #server.stop()
    except Exception:
        traceback.print_exc(file=sys.stdout)
    sys.exit(0)

if __name__ == "__main__":
    main()