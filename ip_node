#!/usr/bin/python
from p2p.peer import InfinitiPeer
from infiniti.params import *
from p2p.protocol.serializers import *
from p2p.protocol.queues import MemPoolManager
from p2p.rpc import RPCServer
import threading, socket
import sys, traceback
import sched, time, os

from utils.db import open_db 

from json import load
from urllib2 import urlopen

from utils.daemonize import Daemon

#try:
#	ip_address = load(urlopen('https://api.ipify.org/?format=json'))['ip'] 
#	port = param_query(NETWORK,'p2p_port')
#except Exception:
#	print "Internet connection not found!"
#	sys.exit(0)

class Infiniti(InfinitiPeer):
	db = None   
	socket = None
	mempool_manager = None
	s_send_ping = None
	s_get_peers = None
	s_ping_event = None
	s_peers_event = None
	counter = 0
	active = threading.Event()

	def touch_peer(self):
		db = open_db(os.path.join(DATA_PATH,"peers"))
		db.Put(self.peerip+":"+str(self.port),str(int(time.time())))

	def message_received(self, message_header, message):
		self.logger.receive("{0} - {1} - {2}".format(self.peerip, message_header.command, str(message)))
		super(Infiniti, self).message_received(message_header, message)

	def send_message(self, message):
		self.logger.send("{0} - {1}".format(self.peerip, str(message)))
		super(Infiniti, self).send_message(message)

	def send_ping(self): 
		p = Ping()
		self.send_message(p)
		self.s_ping_event = self.s_send_ping.enter(617, 1, self.send_ping, ())

	def get_peers(self):
		ga = GetAddr()
		self.send_message(ga)
		self.s_peers_event = self.s_get_peers.enter(631, 1, self.get_peers, ())

	def connected(self):
		# Get list of peers
		self.is_connected = True
		self.touch_peer()
		self.logger.info("{0} - Connected.".format(self.peerip))
		self.active.set()
		gp = GetAddr()
		self.send_message(gp)
		mp = MemPool()
		self.send_message(mp)

	def handle_inv(self, message_header, message):
		self.logger.receive("Received new inventory data from {0}".format(self.peerip))  
		gd = GetData()
		gd.inventory = message.inventory
		self.send_message(gd)

	def handle_tx(self, message_header, message):
		self.logger.receive("Received new mempool transaction from {0}".format(self.peerip))
		self.logger.receive("{0}".format(message))
		self.manager.add(message.calculate_hash())

	def handle_block(self, message_header, message):
		self.logger.receive("Received new block {0} from {1}".format(message.calculate_hash(), self.peerip))
		message.save(self.db)

	def handle_pong(self,messaage_header, message):
		gp = SmsgPing()
		self.send_message(gp)

	def handle_addr(self, message_header, message):
		"""
		This method will handle incoming inventories of network 
		peers.
		Args:
			message_header: The message header
			message: The list of peers
		"""
		self.logger.info("Unpacking new peers from {0}".format(self.peerip))
		for peer in message.addresses:
			peer.save(self.db)

class PeerThread (threading.Thread):
	def __init__(self, threadID, name, logger, peer_ip, peer_port):
		threading.Thread.__init__(self)
		self.threadID = threadID
		self.name = name
		self.counter = self.threadID
		self.logger = logger
		self.client = Infiniti(self.logger, peer_ip, peer_port)

	def stop(self):
		self.logger.info("{0} - Node disconnected.".format(self.client.peerip))
		self.client.exit = True
		db = open_db(os.path.join(DATA_PATH,"peers"))
		db.Put(self.client.peerip+":"+str(self.client.port),str(int(time.time())))

	def run(self):
		self.logger.info("hello???")
		self.client.open(ip_address,port)
		self.client.loop()  

class RPCServerThread(threading.Thread):
	def __init__(self, threadID, name, logger, ip='localhost', port=8000):
		threading.Thread.__init__(self)
		self.threadID = threadID
		self.name = name
		self.counter = self.threadID
		self.rpc_ip = ip
		self.rpc_port = port
		self.logger = logger
		self.rpc_server = RPCServer(self.logger)
		self.halt = False

	def run(self):
		self.rpc_server.start(self.rpc_ip,self.rpc_port)

	def stop(self):
		self.halt = True
		self.rpc_server.httpd.shutdown()
		self.logger.info("RPC server shutdown.")

class InfinitiDaemon(Daemon):
	def load_peer_db(self):
		# trigger garbage collection closing db
		db = open_db(os.path.join(DATA_PATH,"peers"))
		# turn the iterator into a list
		q = []
		for k,v in db.RangeIter():
			q.append((k,int(v)))
		return q

	def create_peer_db(self):
		# trigger garbage collection closing db
		db = open_db(os.path.join(DATA_PATH,"peers"))
		import leveldb
		wb = leveldb.WriteBatch()
		for seed in SEEDS:
			wb.Put(seed[0],str(seed[1]))
		db.Write(wb)

	def get_peers(self):
		# Clean up dead threads 
		self.logger.info("Network spider looking for peers.")        
		for t in self.threads:
			if t.client.exit or t.client.error:
				self.threads.remove(t)
		peers = self.load_peer_db() 
		if len(peers) == 0:
			self.create_peer_db()
			peers = self.load_peer_db() 
		for k,v in peers:
			if v > -1:
				peer_ip, peer_port = k.split(":")
				peer_port = int(peer_port)
				peer_found = False
				# make sure it's not already running
				for t in self.threads:
					if peer_ip == t.client.peerip:
						peer_found = True
				if not peer_found:
					self.counter += 1
					thread = PeerThread(self.counter, "Peer-" + str(self.counter), self.logger, peer_ip, peer_port)
					thread.daemon=True
					thread.start()
					self.threads.append(thread)
		self.last_peers = time.time()                                                        

	def run(self):
		# Register the signal handlers
		self.logger.info("Infiniti starting.")
		try:
			self.threads = []
			self.counter = 0
			self.rpc_server = RPCServerThread(self.counter, "RPCServer", self.logger)
			self.rpc_server.start()
			self.counter += 1
			self.last_peers = time.time() - 100                                                        
			while not self.got_sigterm():
				if self.last_peers < time.time() - 60: # try new peers every 60 seconds
					self.get_peers() 
				time.sleep(1)
			self.halt()
		except Exception as e:
			self.logger.error(e, exc_info=True)
			self.logger.error("Infiniti Shutting down due to errors.")
			sys.exit(1)

	def halt(self):  # signum and frame are mandatory
		for t in self.threads:
			t.stop()
		self.rpc_server.stop()
		self.logger.info("Infiniti Shutting down.")

if __name__ == "__main__":
	infiniti = InfinitiDaemon(PID_FILE)
	if len(sys.argv) == 2:
		if 'start' == sys.argv[1]:
			print "Starting Infiniti..."
			infiniti.start()
		elif 'stop' == sys.argv[1]:
			print "Stopping Infiniti..."
			infiniti.stop()
		elif 'restart' == sys.argv[1]:
			infiniti.restart()
		elif 'status' == sys.argv[1]:
			try:
				pf = file(PIDFILE,'r')
				pid = int(pf.read().strip())
				pf.close()
			except IOError:
				pid = None
			except SystemExit:
				pid = None
			if pid:
				print 'Infiniti is running as pid %s' % pid
			else:
				print 'Infiniti is not running.'
		else:
			print "Unknown command"
			sys.exit(2)
	else:
		print "usage: %s start|stop|restart|status" % sys.argv[0]
		sys.exit(2)
